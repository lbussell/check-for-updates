name: 'Check for Updates'
description: 'Check for software updates using endoflife.date and create issues for new releases'
author: 'lbussell'

inputs:
  product:
    description: 'The endoflife.date product ID (e.g., ubuntu, alpine-linux)'
    required: true
  token:
    description: 'GitHub token for creating issues. Requires issues: write permissions.'
    required: false
    default: ${{ github.token }}
  labels:
    description: 'Comma-separated list of labels to add to the issue (e.g., "dependencies,update-available")'
    required: false
    default: ''
  title-template:
    description: 'Mustache template for the issue title.'
    required: false
    default: 'New {{product}} release: {{cycle}}{{^cycle}}{{latest}}{{/cycle}}'
  body-template:
    description: 'Mustache template for the issue body.'
    required: false
    default: |
      A new version of **{{product}}** is available!

      - **Version**: {{cycle}}{{^cycle}}{{latest}}{{/cycle}}
      - **Release Date**: {{releaseDate}}{{^releaseDate}}{{release}}{{/release}}{{^releaseDate}}{{^release}}Unknown{{/release}}{{/releaseDate}}
      - **End of Life**: {{eol}}{{^eol}}Unknown{{/eol}}
      - **LTS**: {{lts}}

      Previous version: {{cachedVersion}}

      For more information, visit: https://endoflife.date/{{product}}

runs:
  using: 'composite'
  steps:
    - name: Install dependencies
      shell: bash
      run: npm ci

    - name: Restore cached version
      id: cache-restore
      uses: actions/cache/restore@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
      with:
        path: .endoflife-cache
        key: endoflife-${{ inputs.product }}

    - name: Check for updates
      id: check-for-updates
      uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
      env:
        PRODUCT: ${{ inputs.product }}
        LABELS: ${{ inputs.labels }}
        TITLE_TEMPLATE: ${{ inputs.title-template }}
        BODY_TEMPLATE: ${{ inputs.body-template }}
      with:
        github-token: ${{ inputs.token }}
        script: |
          const fs = require('fs');
          const path = require('path');
          const Mustache = require('mustache');

          const product = process.env.PRODUCT;
          const labelsInput = process.env.LABELS || '';
          const titleTemplate = process.env.TITLE_TEMPLATE;
          const bodyTemplate = process.env.BODY_TEMPLATE;

          // Parse labels from comma-separated string
          const labels = labelsInput
            .split(',')
            .map(label => label.trim())
            .filter(label => label.length > 0);

          // Fetch latest release from endoflife.date API
          core.info(`Checking for updates to ${product}...`);

          const response = await fetch(`https://endoflife.date/api/${product}.json`);
          if (!response.ok) {
            throw new Error(`Failed to fetch data for ${product}: ${response.statusText}`);
          }

          const releases = await response.json();
          if (!releases || releases.length === 0) {
            throw new Error(`No releases found for ${product}`);
          }

          // Get the latest release
          const latestRelease = releases[0];
          const latestVersion = latestRelease.cycle || latestRelease.latest;

          core.info(`Latest version: ${latestVersion}`);

          // Read cached version
          const cacheDir = '.endoflife-cache';
          const cacheFile = path.join(cacheDir, `${product}.txt`);
          let cachedVersion = null;

          if (fs.existsSync(cacheFile)) {
            cachedVersion = fs.readFileSync(cacheFile, 'utf8').trim();
            core.info(`Cached version: ${cachedVersion}`);
          } else {
            core.info('No cached version found');
          }

          // Check if there's a new release
          if (cachedVersion !== latestVersion) {
            core.info(`New release detected: ${latestVersion}`);

            // Create issue
            const templateData = {
              ...latestRelease,
              product,
              cachedVersion: cachedVersion || 'None'
            };
            const issueTitle = Mustache.render(titleTemplate, templateData);
            const issueBody = Mustache.render(bodyTemplate, templateData);

            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: issueTitle,
              body: issueBody,
              labels: labels
            });

            core.info(`Created issue #${issue.data.number}`);

            // Update cache file
            if (!fs.existsSync(cacheDir)) {
              fs.mkdirSync(cacheDir, { recursive: true });
            }
            fs.writeFileSync(cacheFile, latestVersion);
            core.info(`Updated cache with version: ${latestVersion}`);

            core.setOutput('new-version', latestVersion);
            core.setOutput('issue-number', issue.data.number);
          } else {
            core.info('No new release detected');
            core.setOutput('new-version', '');
            core.setOutput('issue-number', '');
          }

    - name: Save cached version
      uses: actions/cache/save@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
      if: always()
      with:
        path: .endoflife-cache
        key: endoflife-${{ inputs.product }}

outputs:
  new-version:
    description: 'The new version if one was found, empty string otherwise'
    value: ${{ steps.check-for-updates.outputs.new-version }}
  issue-number:
    description: 'The issue number created if a new version was found, empty string otherwise'
    value: ${{ steps.check-for-updates.outputs.issue-number }}

branding:
  icon: 'alert-circle'
  color: 'blue'
